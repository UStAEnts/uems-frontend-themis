// [package-gen]: version=GO28EYvq/ia43Quj0HrgzvtCzYz/xnYgTwlEQs38GB8=

/**
 * This file was generated by __package-gen.ts in the gateway project! You should not be editing this file by hand as
 * the types and functions here are generated entirely from the source code of gateway. If there is a bug in the
 * implementation it means there is either a bug in the source of the server, in which case you should edit the
 * annotations in the project, or it means there is a bug in the source generation (probably more likely) in which case
 * you need to edit the generation file, currently at 'src/.internal/__package-gen.ts'.
 *
 * TL;DR - DON'T EDIT THIS FILE - edit either 'src/attachments/*' in gateway or 'src/.internal/__package-gen.ts' in
 * gateway
 */
/* eslint-disable */
import axios from 'axios';

const ROOT_URL = '/api';

export type UEMSResponse<T> =
	| {
			status: 'OK' | 'PARTIAL';
			result: T;
	  }
	| {
			status: 'FAILED';
			error: string;
	  };

interface HttpClient {
	get(url: string, query: any): Promise<any>;
	post(url: string, query: any, body: any): Promise<any>;
	patch(url: string, query: any, body: any): Promise<any>;
	delete(url: string, query: any): Promise<any>;
}

class DefaultUemsHttpClient implements HttpClient {
	private readonly headers = {
		headers: {
			'Content-Type': 'application/json',
			Accepts: 'application/json',
		},
	};
	get(url: string, query: any): Promise<any> {
		return axios
			.get(ROOT_URL + url, { params: query, ...this.headers })
			.then((d) => d.data);
	}
	post(url: string, query: any, body: any): Promise<any> {
		return axios
			.post(ROOT_URL + url, body, { params: query, ...this.headers })
			.then((d) => d.data);
	}
	patch(url: string, query: any, body: any): Promise<any> {
		return axios
			.patch(ROOT_URL + url, body, { params: query, ...this.headers })
			.then((d) => d.data);
	}
	delete(url: string, query: any): Promise<any> {
		return axios
			.delete(ROOT_URL + url, { params: query, ...this.headers })
			.then((d) => d.data);
	}
}

export type APIEquipmentGetQuery = {
	amount?: number | undefined;
	assetID?: string | undefined;
	category?: string | undefined;
	date?: number | undefined;
	id?: string | undefined;
	locationID?: string | undefined;
	locationSpecifier?: string | undefined;
	managerID?: string | undefined;
	manufacturer?: string | undefined;
	miscIdentifier?: string | undefined;
	model?: string | undefined;
	name?: string | undefined;
};

export type POSTEquipmentBody = {
	name: string;
	manufacturer: string;
	model: string;
	amount: number;
	location: string;
	category: string;
	assetID?: string | undefined;
	miscIdentifier?: string | undefined;
	locationSpecifier?: string | undefined;
};

export type APIEquipmentIdGetQuery = {};

export type PATCHEquipmentIdBody = {
	assetID?: string | undefined;
	name?: string | undefined;
	manufacturer?: string | undefined;
	model?: string | undefined;
	miscIdentifier?: string | undefined;
	amount?: number | undefined;
	locationID?: string | undefined;
	locationSpecifier?: string | undefined;
	managerID?: string | undefined;
	category?: string | undefined;
};

export type APIEntsGetQuery = {
	id?: string | undefined;
	name?: string | undefined;
	color?: string | undefined;
	icon?: string | undefined;
};

export type POSTEntsBody = {
	name: string;
	icon: string;
	color: string;
};

export type PATCHEntsIdBody = {
	name?: string | undefined;
	icon?: string | undefined;
	color?: string | undefined;
};

export type POSTEventsBody = {
	name: string;
	venue: string;
	start: number;
	end: number;
	attendance: number;
	state?: string | undefined;
	ents?: string | undefined;
};

export type APIEventsGetQuery = {
	attendance?: number | undefined;
	attendanceGreater?: number | undefined;
	attendanceLess?: number | undefined;
	end?: number | undefined;
	endAfter?: number | undefined;
	endBefore?: number | undefined;
	entsID?: string | undefined;
	name?: string | undefined;
	start?: number | undefined;
	startAfter?: number | undefined;
	startBefore?: number | undefined;
	stateID?: string | undefined;
	venueCriteria?: string | undefined;
	venueIDs?: string[] | undefined;
};

export type PATCHEventsIdBody = {
	name?: string | undefined;
	start?: number | undefined;
	end?: number | undefined;
	attendance?: number | undefined;
	addVenues?: string[] | undefined;
	removeVenues?: string[] | undefined;
	ents?: string | undefined;
	state?: string | undefined;
	reserved?: boolean | undefined;
};

export type POSTEventsIdCommentsBody = {
	topic?: string | undefined;
	requiresAttention?: boolean | undefined;
	body: string;
};

export type POSTEventsIdFilesBody = {
	fileID: string;
};

export type APIEventsEventIDSignupsGetQuery = {
	id?: string | undefined;
	date?: number | undefined;
	userid?: string | undefined;
	dateRangeBegin?: number | undefined;
	dateRangeEnd?: number | undefined;
	role?: string | undefined;
};

export type POSTEventsEventidSignupsBody = {
	role: string;
	signupUser?: string | undefined;
};

export type PATCHEventsEventidSignupsIdBody = {
	role: string;
};

export type APIStatesGetQuery = {
	name?: string | undefined;
	icon?: string | undefined;
	color?: string | undefined;
	id?: string | undefined;
};

export type POSTStatesBody = {
	name: string;
	icon: string;
	color: string;
};

export type PATCHStatesIdBody = {
	name?: string | undefined;
	icon?: string | undefined;
	color?: string | undefined;
};

export type POSTVenuesBody = {
	name: string;
	capacity: number;
	color: string;
};

export type APIVenuesGetQuery = {
	capacity?: number | undefined;
	capacityGreater?: number | undefined;
	capacityLess?: number | undefined;
	name?: string | undefined;
};

export type PATCHVenuesIdBody = {
	name?: string | undefined;
	capacity?: number | undefined;
	color?: string | undefined;
};

export type APIFilesGetQuery = {
	date?: number | undefined;
	filename?: string | undefined;
	id?: string | undefined;
	name?: string | undefined;
	size?: number | undefined;
	type?: string | undefined;
	userid?: string | undefined;
	sizeGreater?: number | undefined;
	sizeLess?: number | undefined;
};

export type POSTFilesBody = {
	name: string;
	filename: string;
	size: number;
	type: string;
};

export type PATCHFilesIdBody = {
	name: string;
	type: string;
};

export type APITopicsGetQuery = {
	name?: string | undefined;
	icon?: string | undefined;
	color?: string | undefined;
	description?: string | undefined;
	id?: string | undefined;
};

export type POSTTopicsBody = {
	name: string;
	icon: string;
	color: string;
	description: string;
};

export type PATCHTopicsIdBody = {
	name?: string | undefined;
	icon?: string | undefined;
	color?: string | undefined;
	description?: string | undefined;
};

export type APIUserGetQuery = {
	email: string;
	id: string;
	name: string;
	username: string;
};

export type PATCHUserIdBody = {
	name?: string | undefined;
	username?: string | undefined;
	email?: string | undefined;
	profile?: string | undefined;
};

export type EquipmentList = {
	/** The unique ID of this piece of equipment */
	id: string;
	/** The asset ID tag assigned to this piece of equipment is one has been allocated */
	assetID?: string | undefined;
	/** The human readable name of this equipment */
	name: string;
	/** The original manufacturer of this equipment */
	manufacturer: string;
	/** The specific model of this equipment */
	model: string;
	/** An additional identifier in the event the manufacturer and model are not sufficient */
	miscIdentifier?: string | undefined;
	/** The amount of this piece of equipment currently available */
	amount: number;
	/** The venue in which this equipment is stored */
	location: {
		/** The unique ID of this venue */
		id: string;
		/** The human readable name of the venue */
		name: string;
		/** The amount of people that can fit in the venue during a traditional use case */
		capacity: number;
		/** The colour to represent this venue if required */
		color?: string | undefined;
		/** The user who manages this venue */
		user: {
			/** The ID of this user on the backend store, this is distinct from their username */
			id: string;
			/** The real name of the user */
			name: string;
			/** The username of this user */
			username: string;
			/** The profile picture for this user, if not provided it means the user has not uploaded one */
			profile?: string | undefined;
			/** The email address of this user, optionally provided depending on the query */
			email?: string | undefined;
		};
	};
	/** Additional information about where in the venue this piece of equipment has been stored */
	locationSpecifier?: string | undefined;
	/** The user assigned to manage this piece of equipment and should be the first call when needing information about it */
	manager: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The date the equipment was purchased */
	date: number;
	/** The textual category of this equipment */
	category: string;
}[];

export type ModifyResponse = string[];

export type Equipment = {
	/** The unique ID of this piece of equipment */
	id: string;
	/** The asset ID tag assigned to this piece of equipment is one has been allocated */
	assetID?: string | undefined;
	/** The human readable name of this equipment */
	name: string;
	/** The original manufacturer of this equipment */
	manufacturer: string;
	/** The specific model of this equipment */
	model: string;
	/** An additional identifier in the event the manufacturer and model are not sufficient */
	miscIdentifier?: string | undefined;
	/** The amount of this piece of equipment currently available */
	amount: number;
	/** The venue in which this equipment is stored */
	location: {
		/** The unique ID of this venue */
		id: string;
		/** The human readable name of the venue */
		name: string;
		/** The amount of people that can fit in the venue during a traditional use case */
		capacity: number;
		/** The colour to represent this venue if required */
		color?: string | undefined;
		/** The user who manages this venue */
		user: {
			/** The ID of this user on the backend store, this is distinct from their username */
			id: string;
			/** The real name of the user */
			name: string;
			/** The username of this user */
			username: string;
			/** The profile picture for this user, if not provided it means the user has not uploaded one */
			profile?: string | undefined;
			/** The email address of this user, optionally provided depending on the query */
			email?: string | undefined;
		};
	};
	/** Additional information about where in the venue this piece of equipment has been stored */
	locationSpecifier?: string | undefined;
	/** The user assigned to manage this piece of equipment and should be the first call when needing information about it */
	manager: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The date the equipment was purchased */
	date: number;
	/** The textual category of this equipment */
	category: string;
};

export type EntStateList = {
	/** The unique ID of this ent state */
	id: string;
	/** The name of this ent state */
	name: string;
	/** The hex colour of the ent state */
	color: string;
	/** The icon of this ent state, in a format that can be displayed using the frontend client */
	icon: string;
}[];

export type EntState = {
	/** The unique ID of this ent state */
	id: string;
	/** The name of this ent state */
	name: string;
	/** The hex colour of the ent state */
	color: string;
	/** The icon of this ent state, in a format that can be displayed using the frontend client */
	icon: string;
};

export type EventList = {
	/** The unique ID for this event */
	id: string;
	/** The name of the event */
	name: string;
	/** The unix-second timestamp UTC when the event will begin */
	start: number;
	/** The unix-second UTC timestamp when the event finishes */
	end: number;
	/** The venues in which this event takes place */
	venues: {
		/** The unique ID of this venue */
		id: string;
		/** The human readable name of the venue */
		name: string;
		/** The amount of people that can fit in the venue during a traditional use case */
		capacity: number;
		/** The colour to represent this venue if required */
		color?: string | undefined;
		/** The user who manages this venue */
		user: {
			/** The ID of this user on the backend store, this is distinct from their username */
			id: string;
			/** The real name of the user */
			name: string;
			/** The username of this user */
			username: string;
			/** The profile picture for this user, if not provided it means the user has not uploaded one */
			profile?: string | undefined;
			/** The email address of this user, optionally provided depending on the query */
			email?: string | undefined;
		};
	}[];
	/** The anticipated attendance of this event */
	attendance: number;
	/** The ent state of this event */
	ents?:
		| {
				/** The unique ID of this ent state */
				id: string;
				/** The name of this ent state */
				name: string;
				/** The hex colour of the ent state */
				color: string;
				/** The icon of this ent state, in a format that can be displayed using the frontend client */
				icon: string;
		  }
		| undefined;
	/** The state of this event approval */
	state?:
		| {
				/** The unique ID of this state */
				id: string;
				/** The name of this state */
				name: string;
				/** The color of this state */
				color: string;
				/** The icon of this state in a format that can be rendered by the frontend */
				icon: string;
		  }
		| undefined;
	/** The user who is running this event */
	author: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** If this space and time has been reserved for this event */
	reserved?: boolean | undefined;
}[];

export type UEMSEventWithChangelog = {
	event: {
		/** The unique ID for this event */
		id: string;
		/** The name of the event */
		name: string;
		/** The unix-second timestamp UTC when the event will begin */
		start: number;
		/** The unix-second UTC timestamp when the event finishes */
		end: number;
		/** The venues in which this event takes place */
		venues: {
			/** The unique ID of this venue */
			id: string;
			/** The human readable name of the venue */
			name: string;
			/** The amount of people that can fit in the venue during a traditional use case */
			capacity: number;
			/** The colour to represent this venue if required */
			color?: string | undefined;
			/** The user who manages this venue */
			user: {
				/** The ID of this user on the backend store, this is distinct from their username */
				id: string;
				/** The real name of the user */
				name: string;
				/** The username of this user */
				username: string;
				/** The profile picture for this user, if not provided it means the user has not uploaded one */
				profile?: string | undefined;
				/** The email address of this user, optionally provided depending on the query */
				email?: string | undefined;
			};
		}[];
		/** The anticipated attendance of this event */
		attendance: number;
		/** The ent state of this event */
		ents?:
			| {
					/** The unique ID of this ent state */
					id: string;
					/** The name of this ent state */
					name: string;
					/** The hex colour of the ent state */
					color: string;
					/** The icon of this ent state, in a format that can be displayed using the frontend client */
					icon: string;
			  }
			| undefined;
		/** The state of this event approval */
		state?:
			| {
					/** The unique ID of this state */
					id: string;
					/** The name of this state */
					name: string;
					/** The color of this state */
					color: string;
					/** The icon of this state in a format that can be rendered by the frontend */
					icon: string;
			  }
			| undefined;
		/** The user who is running this event */
		author: {
			/** The ID of this user on the backend store, this is distinct from their username */
			id: string;
			/** The real name of the user */
			name: string;
			/** The username of this user */
			username: string;
			/** The profile picture for this user, if not provided it means the user has not uploaded one */
			profile?: string | undefined;
			/** The email address of this user, optionally provided depending on the query */
			email?: string | undefined;
		};
		/** If this space and time has been reserved for this event */
		reserved?: boolean | undefined;
	};
	changelog: never[];
};

export type CommentList = {
	/** The unique identifier for this comment */
	id: string;
	/** The category of assets on which this comment has been placed, used to locate the service relevant to this comment */
	assetType: string;
	/** The unique identifier for the asset against which this comment has been placed */
	assetID: string;
	/** The user who created this comment */
	poster: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The time (unix-second timestamp UTC) at which this comment was created */
	posted: number;
	/** The topic under which this comment has been assigned */
	topic?:
		| {
				id: string;
				name: string;
				color: string;
				icon: string;
				description: string;
		  }
		| undefined;
	/** If this comment has been marked as 'requiring attention' by another user */
	requiresAttention?: boolean | undefined;
	/** The time (unix-second timestamp UTC) at which this comment was attended to by another user */
	attendedDate?: number | undefined;
	/** The user who attended to this comment to disable the flag */
	attendedBy?:
		| {
				/** The ID of this user on the backend store, this is distinct from their username */
				id: string;
				/** The real name of the user */
				name: string;
				/** The username of this user */
				username: string;
				/** The profile picture for this user, if not provided it means the user has not uploaded one */
				profile?: string | undefined;
				/** The email address of this user, optionally provided depending on the query */
				email?: string | undefined;
		  }
		| undefined;
	/** The main content of the comment */
	body: string;
}[];

export type UEMSFileList = {
	/** The unique ID of the file */
	id: string;
	/** The human readable name of the file - this is user chosen and does not need to be the actual file name */
	name: string;
	/** The original file name */
	filename: string;
	/** The number of bytes in the file */
	size: number;
	/** The mime type of the file to be used in download requests */
	mime: string;
	/** The owner of this file, originally the user who uploaded it */
	owner: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The type of file */
	type: string;
	/** The unix-second timestamp when the file was uploaded */
	date: number;
	/** The URL at which the file can be downloaded if it is stored at an external location */
	downloadURL: string;
	/** The checksum of the file */
	checksum: string;
}[];

export type SignupList = {
	/** The unique identifier for this signup */
	id: string;
	/** The user who is being signed up to the event */
	user: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The event to which this user is signing up */
	event: {
		/** The unique ID for this event */
		id: string;
		/** The name of the event */
		name: string;
		/** The unix-second timestamp UTC when the event will begin */
		start: number;
		/** The unix-second UTC timestamp when the event finishes */
		end: number;
		/** The venues in which this event takes place */
		venues: {
			/** The unique ID of this venue */
			id: string;
			/** The human readable name of the venue */
			name: string;
			/** The amount of people that can fit in the venue during a traditional use case */
			capacity: number;
			/** The colour to represent this venue if required */
			color?: string | undefined;
			/** The user who manages this venue */
			user: {
				/** The ID of this user on the backend store, this is distinct from their username */
				id: string;
				/** The real name of the user */
				name: string;
				/** The username of this user */
				username: string;
				/** The profile picture for this user, if not provided it means the user has not uploaded one */
				profile?: string | undefined;
				/** The email address of this user, optionally provided depending on the query */
				email?: string | undefined;
			};
		}[];
		/** The anticipated attendance of this event */
		attendance: number;
		/** The ent state of this event */
		ents?:
			| {
					/** The unique ID of this ent state */
					id: string;
					/** The name of this ent state */
					name: string;
					/** The hex colour of the ent state */
					color: string;
					/** The icon of this ent state, in a format that can be displayed using the frontend client */
					icon: string;
			  }
			| undefined;
		/** The state of this event approval */
		state?:
			| {
					/** The unique ID of this state */
					id: string;
					/** The name of this state */
					name: string;
					/** The color of this state */
					color: string;
					/** The icon of this state in a format that can be rendered by the frontend */
					icon: string;
			  }
			| undefined;
		/** The user who is running this event */
		author: {
			/** The ID of this user on the backend store, this is distinct from their username */
			id: string;
			/** The real name of the user */
			name: string;
			/** The username of this user */
			username: string;
			/** The profile picture for this user, if not provided it means the user has not uploaded one */
			profile?: string | undefined;
			/** The email address of this user, optionally provided depending on the query */
			email?: string | undefined;
		};
		/** If this space and time has been reserved for this event */
		reserved?: boolean | undefined;
	};
	/** The role this user is signing up for */
	role: string;
	/** The unix-second UTC timestamp at which this signup was made */
	date: number;
}[];

export type Signup = {
	/** The unique identifier for this signup */
	id: string;
	/** The user who is being signed up to the event */
	user: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The event to which this user is signing up */
	event: {
		/** The unique ID for this event */
		id: string;
		/** The name of the event */
		name: string;
		/** The unix-second timestamp UTC when the event will begin */
		start: number;
		/** The unix-second UTC timestamp when the event finishes */
		end: number;
		/** The venues in which this event takes place */
		venues: {
			/** The unique ID of this venue */
			id: string;
			/** The human readable name of the venue */
			name: string;
			/** The amount of people that can fit in the venue during a traditional use case */
			capacity: number;
			/** The colour to represent this venue if required */
			color?: string | undefined;
			/** The user who manages this venue */
			user: {
				/** The ID of this user on the backend store, this is distinct from their username */
				id: string;
				/** The real name of the user */
				name: string;
				/** The username of this user */
				username: string;
				/** The profile picture for this user, if not provided it means the user has not uploaded one */
				profile?: string | undefined;
				/** The email address of this user, optionally provided depending on the query */
				email?: string | undefined;
			};
		}[];
		/** The anticipated attendance of this event */
		attendance: number;
		/** The ent state of this event */
		ents?:
			| {
					/** The unique ID of this ent state */
					id: string;
					/** The name of this ent state */
					name: string;
					/** The hex colour of the ent state */
					color: string;
					/** The icon of this ent state, in a format that can be displayed using the frontend client */
					icon: string;
			  }
			| undefined;
		/** The state of this event approval */
		state?:
			| {
					/** The unique ID of this state */
					id: string;
					/** The name of this state */
					name: string;
					/** The color of this state */
					color: string;
					/** The icon of this state in a format that can be rendered by the frontend */
					icon: string;
			  }
			| undefined;
		/** The user who is running this event */
		author: {
			/** The ID of this user on the backend store, this is distinct from their username */
			id: string;
			/** The real name of the user */
			name: string;
			/** The username of this user */
			username: string;
			/** The profile picture for this user, if not provided it means the user has not uploaded one */
			profile?: string | undefined;
			/** The email address of this user, optionally provided depending on the query */
			email?: string | undefined;
		};
		/** If this space and time has been reserved for this event */
		reserved?: boolean | undefined;
	};
	/** The role this user is signing up for */
	role: string;
	/** The unix-second UTC timestamp at which this signup was made */
	date: number;
};

export type StateList = {
	/** The unique ID of this state */
	id: string;
	/** The name of this state */
	name: string;
	/** The color of this state */
	color: string;
	/** The icon of this state in a format that can be rendered by the frontend */
	icon: string;
}[];

export type State = {
	/** The unique ID of this state */
	id: string;
	/** The name of this state */
	name: string;
	/** The color of this state */
	color: string;
	/** The icon of this state in a format that can be rendered by the frontend */
	icon: string;
};

export type VenueList = {
	/** The unique ID of this venue */
	id: string;
	/** The human readable name of the venue */
	name: string;
	/** The amount of people that can fit in the venue during a traditional use case */
	capacity: number;
	/** The colour to represent this venue if required */
	color?: string | undefined;
	/** The user who manages this venue */
	user: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
}[];

export type Venue = {
	/** The unique ID of this venue */
	id: string;
	/** The human readable name of the venue */
	name: string;
	/** The amount of people that can fit in the venue during a traditional use case */
	capacity: number;
	/** The colour to represent this venue if required */
	color?: string | undefined;
	/** The user who manages this venue */
	user: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
};

export type FileCreateReply = {
	status: 'OK';
	result: string[];
	uploadURI: string;
};

export type UEMSFile = {
	/** The unique ID of the file */
	id: string;
	/** The human readable name of the file - this is user chosen and does not need to be the actual file name */
	name: string;
	/** The original file name */
	filename: string;
	/** The number of bytes in the file */
	size: number;
	/** The mime type of the file to be used in download requests */
	mime: string;
	/** The owner of this file, originally the user who uploaded it */
	owner: {
		/** The ID of this user on the backend store, this is distinct from their username */
		id: string;
		/** The real name of the user */
		name: string;
		/** The username of this user */
		username: string;
		/** The profile picture for this user, if not provided it means the user has not uploaded one */
		profile?: string | undefined;
		/** The email address of this user, optionally provided depending on the query */
		email?: string | undefined;
	};
	/** The type of file */
	type: string;
	/** The unix-second timestamp when the file was uploaded */
	date: number;
	/** The URL at which the file can be downloaded if it is stored at an external location */
	downloadURL: string;
	/** The checksum of the file */
	checksum: string;
};

export type TopicList = {
	id: string;
	name: string;
	color: string;
	icon: string;
	description: string;
}[];

export type Topic = {
	id: string;
	name: string;
	color: string;
	icon: string;
	description: string;
};

export type UserList = {
	/** The ID of this user on the backend store, this is distinct from their username */
	id: string;
	/** The real name of the user */
	name: string;
	/** The username of this user */
	username: string;
	/** The profile picture for this user, if not provided it means the user has not uploaded one */
	profile?: string | undefined;
	/** The email address of this user, optionally provided depending on the query */
	email?: string | undefined;
}[];

export type User = {
	/** The ID of this user on the backend store, this is distinct from their username */
	id: string;
	/** The real name of the user */
	name: string;
	/** The username of this user */
	username: string;
	/** The profile picture for this user, if not provided it means the user has not uploaded one */
	profile?: string | undefined;
	/** The email address of this user, optionally provided depending on the query */
	email?: string | undefined;
};

export type Whoami = {
	username: string;
	profile: string;
	name: string;
};

export type FeatureConfig = {
	equipment: boolean;
	ops: boolean;
};

class APIEquipmentId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get details for a single equipment entry
	 *
	 * Retrieves information about a single equipment entry based on ID.
	 *
	 */ get = (
		query: APIEquipmentIdGetQuery
	): Promise<UEMSResponse<Equipment>> => {
		return this._http.get(`/equipment/${encodeURIComponent(this.id)}`, query);
	};

	/**
	 * Deletes a piece of equipment
	 *
	 * Removes a single equipment entry from the database
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/equipment/${encodeURIComponent(this.id)}`,
			undefined
		);
	};

	/**
	 * Deletes an equipment entry
	 *
	 * Deletes this piece of equipment from the records unless there are dependent objects on it
	 *
	 */ patch = (
		body: PATCHEquipmentIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/equipment/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};
}

class APIEquipment {
	constructor(private _http: HttpClient) {}
	/**
	 * Search for equipment
	 *
	 * Full querying support for equipment is provided through this endpoint. Individual equipment entries can be looked up via the /equipment/{id} endpoint.
	 *
	 */ get = (
		query: APIEquipmentGetQuery
	): Promise<UEMSResponse<EquipmentList>> => {
		return this._http.get(`/equipment`, query);
	};

	/**
	 * Creates a new equipment asset
	 *
	 * This adds a new piece of equipment to the entry catalogue
	 *
	 */ post = (
		body: POSTEquipmentBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(`/equipment`, undefined, body);
	};

	id = (parameter: string): APIEquipmentId => {
		return new APIEquipmentId(this._http, parameter);
	};
}

class APIEntsId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Retrieve a single ent state
	 *
	 * Returns a single ent state record based on its unique ID
	 *
	 */ get = (): Promise<UEMSResponse<EntState>> => {
		return this._http.get(`/ents/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Delete an ents state
	 *
	 * Deletes an ent state from the system provided there are no other objects depending on this object
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(`/ents/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Updates an ent state
	 *
	 * Updates the properties of an ents state with the modifications specified in the body
	 *
	 */ patch = (
		body: PATCHEntsIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/ents/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};
}

class APIEnts {
	constructor(private _http: HttpClient) {}
	/**
	 * Queries ent state
	 *
	 * Supports querying a set of ents states based on a range of properties
	 *
	 */ get = (query: APIEntsGetQuery): Promise<UEMSResponse<EntStateList>> => {
		return this._http.get(`/ents`, query);
	};

	/**
	 * Create a new ent state
	 *
	 * Creates a new ent state and returns its identifier based on the body provided
	 *
	 */ post = (body: POSTEntsBody): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(`/ents`, undefined, body);
	};

	id = (parameter: string): APIEntsId => {
		return new APIEntsId(this._http, parameter);
	};
}

class APIEventsIdCommentsCommentIDAttention {
	constructor(
		private _http: HttpClient,
		private id: string,
		private commentID: string
	) {}
	/**
	 * Marks this comment as requiring attention
	 *
	 * This will flag this comment as needing attention from another member of staff before the event can go ahead
	 *
	 */ post = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(
			`/events/${encodeURIComponent(this.id)}/comments/${encodeURIComponent(
				this.commentID
			)}/attention`,
			undefined,
			undefined
		);
	};
}

class APIEventsIdCommentsCommentIDResolve {
	constructor(
		private _http: HttpClient,
		private id: string,
		private commentID: string
	) {}
	/**
	 * Marks a comment as resolved
	 *
	 * Marks the comment on the given event as resolved meaning it no longer requires attention by another staff member
	 *
	 */ post = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(
			`/events/${encodeURIComponent(this.id)}/comments/${encodeURIComponent(
				this.commentID
			)}/resolve`,
			undefined,
			undefined
		);
	};
}

class APIEventsIdCommentsCommentID {
	constructor(
		private _http: HttpClient,
		private id: string,
		private commentID: string
	) {}
	attention = (): APIEventsIdCommentsCommentIDAttention => {
		return new APIEventsIdCommentsCommentIDAttention(
			this._http,
			this.id,
			this.commentID
		);
	};

	resolve = (): APIEventsIdCommentsCommentIDResolve => {
		return new APIEventsIdCommentsCommentIDResolve(
			this._http,
			this.id,
			this.commentID
		);
	};
}

class APIEventsIdComments {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Returns all comments on the event
	 *
	 * Returns all comments which are associated with the given event identifier
	 *
	 */ get = (): Promise<UEMSResponse<CommentList>> => {
		return this._http.get(
			`/events/${encodeURIComponent(this.id)}/comments`,
			undefined
		);
	};

	/**
	 * Posts a new comment on this event
	 *
	 * Adds a new comment to the event associated with the id provided
	 *
	 */ post = (
		body: POSTEventsIdCommentsBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(
			`/events/${encodeURIComponent(this.id)}/comments`,
			undefined,
			body
		);
	};

	commentID = (parameter: string): APIEventsIdCommentsCommentID => {
		return new APIEventsIdCommentsCommentID(this._http, this.id, parameter);
	};
}

class APIEventsIdFiles {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get all files for an event
	 *
	 * Returns all files associated with a given event
	 *
	 */ get = (): Promise<UEMSResponse<UEMSFileList>> => {
		return this._http.get(
			`/events/${encodeURIComponent(this.id)}/files`,
			undefined
		);
	};

	/**
	 * Link a file to an event
	 *
	 * Links a file by ID to the event ID specified in the path
	 *
	 */ post = (
		body: POSTEventsIdFilesBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(
			`/events/${encodeURIComponent(this.id)}/files`,
			undefined,
			body
		);
	};
}

class APIEventsId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Updates this event
	 *
	 * This will modify the properties of the event as requested
	 *
	 */ patch = (
		body: PATCHEventsIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/events/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};

	/**
	 * Delete an event
	 *
	 * This will try and delete the event as long as no other objects rely on the entity. This is restricted to staff as for users events should be cancelled rather than deleted to provide a comprehensive audit trail of the processes.
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/events/${encodeURIComponent(this.id)}`,
			undefined
		);
	};

	/**
	 * Retrieves a single event
	 *
	 * Returns the event associated with the given ID if one exists
	 *
	 */ get = (): Promise<UEMSResponse<UEMSEventWithChangelog>> => {
		return this._http.get(`/events/${encodeURIComponent(this.id)}`, undefined);
	};

	comments = (): APIEventsIdComments => {
		return new APIEventsIdComments(this._http, this.id);
	};

	files = (): APIEventsIdFiles => {
		return new APIEventsIdFiles(this._http, this.id);
	};
}

class APIEventsReview {
	constructor(private _http: HttpClient) {}
	/**
	 * Retrieves all events requiring attention
	 *
	 * This will return all events that are currently marked with the review state or who have not yet had their time reserved in the booking system
	 *
	 */ get = (): Promise<UEMSResponse<EventList>> => {
		return this._http.get(`/events/review`, undefined);
	};
}

class APIEventsEventIDFilesFileID {
	constructor(
		private _http: HttpClient,
		private eventID: string,
		private fileID: string
	) {}
	/**
	 * Unlink a file an event
	 *
	 * Removes any link between this file and event if one exists
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/events/${encodeURIComponent(this.eventID)}/files/${encodeURIComponent(
				this.fileID
			)}`,
			undefined
		);
	};
}

class APIEventsEventIDFiles {
	constructor(private _http: HttpClient, private eventID: string) {}
	fileID = (parameter: string): APIEventsEventIDFilesFileID => {
		return new APIEventsEventIDFilesFileID(this._http, this.eventID, parameter);
	};
}

class APIEventsEventIDSignupsId {
	constructor(
		private _http: HttpClient,
		private eventID: string,
		private id: string
	) {}
	/**
	 * Get details of a signup
	 *
	 * This will return details of a single signup identified by ID on an event if the record exists
	 *
	 */ get = (): Promise<UEMSResponse<Signup>> => {
		return this._http.get(
			`/events/${encodeURIComponent(this.eventID)}/signups/${encodeURIComponent(
				this.id
			)}`,
			undefined
		);
	};

	/**
	 * Remove a signup
	 *
	 * With this endpoint you can remove your own signup from an event or the sign up of another user (if you are an ent, ops or admin)
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/events/${encodeURIComponent(this.eventID)}/signups/${encodeURIComponent(
				this.id
			)}`,
			undefined
		);
	};

	/**
	 * Update a signup
	 *
	 * You can change the role of the signup on this signup on the provided event. If you are an admin you can edit any signup, otherwise it will only be your own signups
	 *
	 */ patch = (
		body: PATCHEventsEventidSignupsIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/events/${encodeURIComponent(this.eventID)}/signups/${encodeURIComponent(
				this.id
			)}`,
			undefined,
			body
		);
	};
}

class APIEventsEventIDSignups {
	constructor(private _http: HttpClient, private eventID: string) {}
	/**
	 * Get signups
	 *
	 * Returns signups from the given event, filtered by the given opens
	 *
	 */ get = (
		query: APIEventsEventIDSignupsGetQuery
	): Promise<UEMSResponse<SignupList>> => {
		return this._http.get(
			`/events/${encodeURIComponent(this.eventID)}/signups`,
			query
		);
	};

	/**
	 * Add a signup to an event
	 *
	 * With this endpoint you can register to join an event (authentication as ops or ents required), or sign another user up to the event (must be an admin)
	 *
	 */ post = (
		body: POSTEventsEventidSignupsBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(
			`/events/${encodeURIComponent(this.eventID)}/signups`,
			undefined,
			body
		);
	};

	id = (parameter: string): APIEventsEventIDSignupsId => {
		return new APIEventsEventIDSignupsId(this._http, this.eventID, parameter);
	};
}

class APIEventsEventID {
	constructor(private _http: HttpClient, private eventID: string) {}
	files = (): APIEventsEventIDFiles => {
		return new APIEventsEventIDFiles(this._http, this.eventID);
	};

	signups = (): APIEventsEventIDSignups => {
		return new APIEventsEventIDSignups(this._http, this.eventID);
	};
}

class APIEvents {
	constructor(private _http: HttpClient) {}
	/**
	 * Create a new event
	 *
	 * Creates a new event with the given configuration
	 *
	 */ post = (body: POSTEventsBody): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(`/events`, undefined, body);
	};

	/**
	 * Retrieve events matching a filter
	 *
	 * Returns all events matching the filters defined in the query
	 *
	 */ get = (query: APIEventsGetQuery): Promise<UEMSResponse<EventList>> => {
		return this._http.get(`/events`, query);
	};

	id = (parameter: string): APIEventsId => {
		return new APIEventsId(this._http, parameter);
	};

	review = (): APIEventsReview => {
		return new APIEventsReview(this._http);
	};

	eventID = (parameter: string): APIEventsEventID => {
		return new APIEventsEventID(this._http, parameter);
	};
}

class APIStatesIdEvents {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Returns all events for the given state
	 *
	 * This will return the details of all events which have the given state associated with them
	 *
	 */ get = (): Promise<UEMSResponse<EventList>> => {
		return this._http.get(
			`/states/${encodeURIComponent(this.id)}/events`,
			undefined
		);
	};
}

class APIStatesId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Gets a state
	 *
	 * Returns the properties of a single individual state
	 *
	 */ get = (): Promise<UEMSResponse<State>> => {
		return this._http.get(`/states/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Deletes a state
	 *
	 * This will remove a state from the system provided it is not a required dependency of any other object.
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/states/${encodeURIComponent(this.id)}`,
			undefined
		);
	};

	/**
	 * Update the properties of a state
	 *
	 * The values provided in the body will be updated in the state
	 *
	 */ patch = (
		body: PATCHStatesIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/states/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};

	events = (): APIStatesIdEvents => {
		return new APIStatesIdEvents(this._http, this.id);
	};
}

class APIStatesReview {
	constructor(private _http: HttpClient) {}
	/**
	 * Get review states
	 *
	 * This will return the list of states that have been marked as requiring manual review when assigned to events
	 *
	 */ get = (): Promise<UEMSResponse<StateList>> => {
		return this._http.get(`/states/review`, undefined);
	};
}

class APIStates {
	constructor(private _http: HttpClient) {}
	/**
	 * Search for a state
	 *
	 * Returns all states matching a particular query, otherwise return all the states in the system
	 *
	 */ get = (query: APIStatesGetQuery): Promise<UEMSResponse<StateList>> => {
		return this._http.get(`/states`, query);
	};

	/**
	 * Creates a state
	 *
	 * This will insert the specified state into the system and return the newly appointed ID
	 *
	 */ post = (body: POSTStatesBody): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(`/states`, undefined, body);
	};

	id = (parameter: string): APIStatesId => {
		return new APIStatesId(this._http, parameter);
	};

	review = (): APIStatesReview => {
		return new APIStatesReview(this._http);
	};
}

class APIVenuesIdEvents {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Returns all events taking place in the given venue
	 *
	 * Returns all events that have ever taken place in the given venue
	 *
	 */ get = (): Promise<UEMSResponse<EventList>> => {
		return this._http.get(
			`/venues/${encodeURIComponent(this.id)}/events`,
			undefined
		);
	};
}

class APIVenuesId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get a venue
	 *
	 * Get the properties of a single venue by ID
	 *
	 */ get = (): Promise<UEMSResponse<Venue>> => {
		return this._http.get(`/venues/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Delete a venue
	 *
	 * Removes a venue from the system (physical buildings are unfortunately not removed)
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/venues/${encodeURIComponent(this.id)}`,
			undefined
		);
	};

	/**
	 * Update a venue
	 *
	 * Update the properties of a venue as listed
	 *
	 */ patch = (
		body: PATCHVenuesIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/venues/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};

	events = (): APIVenuesIdEvents => {
		return new APIVenuesIdEvents(this._http, this.id);
	};
}

class APIVenues {
	constructor(private _http: HttpClient) {}
	/**
	 * Create a new venue
	 *
	 * Adds a new venue with the associated properties, building construction is left as an exercise to the reader
	 *
	 */ post = (body: POSTVenuesBody): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(`/venues`, undefined, body);
	};

	/**
	 * Find a venue
	 *
	 * Search for venues against a range of properties
	 * @warn Query parameters are incomplete against the range of possible options defined in uemscommlib
	 */ get = (query: APIVenuesGetQuery): Promise<UEMSResponse<VenueList>> => {
		return this._http.get(`/venues`, query);
	};

	id = (parameter: string): APIVenuesId => {
		return new APIVenuesId(this._http, parameter);
	};
}

class APIFilesIdEvents {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get all events associated with a file
	 *
	 * Returns all events which have been bound with this file
	 *
	 */ get = (): Promise<UEMSResponse<EventList>> => {
		return this._http.get(
			`/files/${encodeURIComponent(this.id)}/events`,
			undefined
		);
	};
}

class APIFilesId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get a single file
	 *
	 * Returns properties for a single file entry
	 *
	 */ get = (): Promise<UEMSResponse<UEMSFile>> => {
		return this._http.get(`/files/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Delete a file
	 *
	 * This will remove a file from the system providing no other objects are currently depending on it
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/files/${encodeURIComponent(this.id)}`,
			undefined
		);
	};

	/**
	 * Update a file
	 *
	 * Update the name and type of a file currently in the system
	 *
	 */ patch = (
		body: PATCHFilesIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/files/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};

	events = (): APIFilesIdEvents => {
		return new APIFilesIdEvents(this._http, this.id);
	};
}

class APIFiles {
	constructor(private _http: HttpClient) {}
	/**
	 * Search for files
	 *
	 * Return files matching the given query
	 *
	 */ get = (query: APIFilesGetQuery): Promise<UEMSResponse<UEMSFileList>> => {
		return this._http.get(`/files`, query);
	};

	/**
	 * Add a new file entry
	 *
	 * This will create a new file entry without any associated content. The actual file upload will take place separately through the returned upload URI to which you should upload the actual content of the file. The result of this call is to createa  file metadata entry only. If you do not upload a file within a certain time frame, the metadata record will be automatically deleted so it is recommended you upload the file immediately after.
	 *
	 */ post = (body: POSTFilesBody): Promise<FileCreateReply> => {
		return this._http.post(`/files`, undefined, body);
	};

	id = (parameter: string): APIFilesId => {
		return new APIFilesId(this._http, parameter);
	};
}

class APITopicsId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get a topic
	 *
	 * Returns all properties associated with the given topic
	 *
	 */ get = (): Promise<UEMSResponse<Topic>> => {
		return this._http.get(`/topics/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Delete a topic
	 *
	 * This will remove a topic provided there are no critical dependencies on it
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(
			`/topics/${encodeURIComponent(this.id)}`,
			undefined
		);
	};

	/**
	 * Update a topic
	 *
	 * This will update the specified properties against the provided topic
	 *
	 */ patch = (
		body: PATCHTopicsIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/topics/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};
}

class APITopics {
	constructor(private _http: HttpClient) {}
	/**
	 * Search topics
	 *
	 * This will return all topics matching the provided filters
	 *
	 */ get = (query: APITopicsGetQuery): Promise<UEMSResponse<TopicList>> => {
		return this._http.get(`/topics`, query);
	};

	/**
	 * Create a new topic
	 *
	 * This will create a new topic with the specified details, returning the newly generated ID
	 *
	 */ post = (body: POSTTopicsBody): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.post(`/topics`, undefined, body);
	};

	id = (parameter: string): APITopicsId => {
		return new APITopicsId(this._http, parameter);
	};
}

class APIUserId {
	constructor(private _http: HttpClient, private id: string) {}
	/**
	 * Get a user
	 *
	 * Retrieves properties on a single user, emails will only be included if you are part of the ops, ents or admin groups
	 *
	 */ get = (): Promise<UEMSResponse<User>> => {
		return this._http.get(`/user/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Delete a user
	 *
	 * Purge a user from existence (in the system, living people are left unharmed). Only usable by admins and will only delete user metadata. Actual user credentials and login permissions should be managed through the associated keycloak or user management platform. If you delete a user their records will be regenerated from keycloak on their next login / authentication assertion
	 *
	 */ delete = (): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.delete(`/user/${encodeURIComponent(this.id)}`, undefined);
	};

	/**
	 * Update user metadata
	 *
	 * This will update internal user metadata about the user. Some properties may be overwritten by keycloak syncing but for example profile should be safe. If you are admin you can change any user otherwise only yourself
	 *
	 */ patch = (
		body: PATCHUserIdBody
	): Promise<UEMSResponse<ModifyResponse>> => {
		return this._http.patch(
			`/user/${encodeURIComponent(this.id)}`,
			undefined,
			body
		);
	};
}

class APIUser {
	constructor(private _http: HttpClient) {}
	/**
	 * Queries users by the given properties
	 *
	 * This will allow you to query users by a range of properties. Emails will not be included unless you are a member of ops, ents or admin and queries by email will not be supported either
	 * @warn Permission management issues?
	 */ get = (query: APIUserGetQuery): Promise<UEMSResponse<UserList>> => {
		return this._http.get(`/user`, query);
	};

	id = (parameter: string): APIUserId => {
		return new APIUserId(this._http, parameter);
	};
}

class APIWhoami {
	constructor(private _http: HttpClient) {}
	/**
	 * Self introspection
	 *
	 * Details of your user account, unfortunately less philosophical answer
	 *
	 */ get = (): Promise<Whoami> => {
		return this._http.get(`/whoami`, undefined);
	};
}

class APIFeatures {
	constructor(private _http: HttpClient) {}
	/**
	 * Get the supported features
	 *
	 * UEMS is packed of features but not all of them are quite ready yet! This endpoint returns which features are currently enabled and exposed to users and which are hidden only in the backend. This only modifies what the frontend should render - all features are available through the API!
	 *
	 */ get = (): Promise<FeatureConfig> => {
		return this._http.get(`/features`, undefined);
	};
}

class API {
	constructor(private _http: HttpClient) {}
	equipment = (): APIEquipment => {
		return new APIEquipment(this._http);
	};

	ents = (): APIEnts => {
		return new APIEnts(this._http);
	};

	events = (): APIEvents => {
		return new APIEvents(this._http);
	};

	states = (): APIStates => {
		return new APIStates(this._http);
	};

	venues = (): APIVenues => {
		return new APIVenues(this._http);
	};

	files = (): APIFiles => {
		return new APIFiles(this._http);
	};

	topics = (): APITopics => {
		return new APITopics(this._http);
	};

	user = (): APIUser => {
		return new APIUser(this._http);
	};

	whoami = (): APIWhoami => {
		return new APIWhoami(this._http);
	};

	features = (): APIFeatures => {
		return new APIFeatures(this._http);
	};
}

const apiInstance = new API(new DefaultUemsHttpClient());

export default apiInstance;
